CREATE DATABASE ONLINE_STORE


/* ПОТРЕБИТЕЛ */
CREATE TABLE ADDRESS_INFO(
    ID INT IDENTITY(1, 1) PRIMARY KEY,
	COUNTRY VARCHAR(50) NOT NULL, 
	CITY VARCHAR(50) NOT NULL,
	STREET VARCHAR(50) NOT NULL,
	NUMBER INT NOT NULL,
)

CREATE TABLE USER_INFO(
    ID INT IDENTITY(1, 1) PRIMARY KEY,
    USERNAME VARCHAR(50) UNIQUE,
	PASSWORD VARCHAR(100),
	IS_BLOCKED BIT CHECK(IS_BLOCKED = 0 or IS_BLOCKED = 1) DEFAULT 0,
	IS_DELETED BIT CHECK(IS_DELETED = 0 or IS_DELETED = 1) DEFAULT 0,
)

CREATE TABLE CUSTOMER(
    ID INT IDENTITY(1, 1) PRIMARY KEY,
	FIRST_NAME VARCHAR(50) NOT NULL,
	LAST_NAME VARCHAR(50) NOT NULL,
	AGE INT CHECK(AGE >= 18) NOT NULL,
	EMAIL VARCHAR(100) NOT NULL,
	PHONE_NUMBER VARCHAR(20) NOT NULL,
	USER_INFO_ID INT NOT NULL FOREIGN KEY REFERENCES USER_INFO(ID),
	ADDRESS_INFO_ID__DEFAULT INT NOT NULL FOREIGN KEY REFERENCES ADDRESS_INFO(ID),
)

ALTER TABLE ADDRESS_INFO
ADD CUTOMER_ID INT FOREIGN KEY REFERENCES CUSTOMER(ID) ON DELETE CASCADE


/* ПРОДУКТ */
CREATE TABLE CATEGORY(
    ID INT PRIMARY KEY,
	NAME VARCHAR(50) NOT NULL,
	CATEGORY_ID__PARENT_CATEGORY INT FOREIGN KEY REFERENCES CATEGORY(ID),
)

CREATE TABLE CHARACTERISTIC(
    ID INT PRIMARY KEY, 
	NAME VARCHAR(100) UNIQUE NOT NULL,
)

CREATE TABLE CATEGORY_CHARACTERISTIC(
   CATEGORY_ID INT NOT NULL FOREIGN KEY REFERENCES CATEGORY(ID),
   CHARACTERISTIC_ID INT NOT NULL FOREIGN KEY REFERENCES CHARACTERISTIC(ID)
   PRIMARY KEY(CATEGORY_ID, CHARACTERISTIC_ID)
)

CREATE TABLE PRODUCT(
    ID INT IDENTITY(1, 1) PRIMARY KEY,
	NAME VARCHAR(100) NOT NULL,
	TOTAL_QUANTITY INT NOT NULL,
	CATEGORY_ID INT FOREIGN KEY REFERENCES CATEGORY(ID),
)

CREATE TABLE PRICE_INFO(
     DELIVERY_PRICE DECIMAL NOT NULL CHECK(DELIVERY_PRICE > 0),
	 SELLING_PRICE DECIMAL NOT NULL CHECK(SELLING_PRICE > 0),
     DATE DATE NOT NULL,
	 PRODUCT_ID INT NOT NULL FOREIGN KEY REFERENCES PRODUCT(ID),
	 PRIMARY KEY(PRODUCT_ID, DATE)
)

CREATE TABLE CHARACTERISTIC_VALUE(
    VALUE VARCHAR(100),
    CHARACTERISTIC_ID INT FOREIGN KEY REFERENCES CHARACTERISTIC(ID),
	PRODUCT_ID INT FOREIGN KEY REFERENCES PRODUCT(ID),
	CATEGORY_ID INT FOREIGN KEY REFERENCES CATEGORY(ID),
	PRIMARY KEY(PRODUCT_ID, CATEGORY_ID, CHARACTERISTIC_ID)
)


/* ПОРЪЧКА */
CREATE TABLE ORDERS(
    ID INT IDENTITY(1, 1) PRIMARY KEY,
	DATETIME DATETIME DEFAULT CURRENT_TIMESTAMP,
	CUSTOMER_ID INT FOREIGN KEY REFERENCES CUSTOMER(ID),
	PAYMENT_STATUS VARCHAR(30) CHECK(PAYMENT_STATUS = 'Неплатена' or  PAYMENT_STATUS = 'Одобрено плащане'),
	DELIVERY_STATUS VARCHAR(30) CHECK(DELIVERY_STATUS = 'Подготвена за изпращане' or DELIVERY_STATUS = 'Подготвена за изпращане'),
	ORDER_ID CHAR(10) UNIQUE,
)

CREATE TABLE ORDERS_PRODUCT(
    ORDERS_ID INT FOREIGN KEY REFERENCES ORDERS(ID),
	PRODUCT_ID INT FOREIGN KEY REFERENCES PRODUCT(ID),
	PRIMARY KEY(ORDERS_ID, PRODUCT_ID)
)

CREATE FUNCTION SplitInts
(
   @List       VARCHAR(MAX),
   @Delimiter  CHAR(1)
)
RETURNS TABLE
AS
   RETURN 
   (
       SELECT Item = CONVERT(INT, Item)
       FROM
       (
           SELECT Item = x.i.value('(./text())[1]', 'INT')
           FROM
           (
               SELECT [XML] = CONVERT(XML, '<i>' 
                    + REPLACE(@List, @Delimiter, '</i><i>') 
                    + '</i>').query('.')
           ) AS a
           CROSS APPLY
           [XML].nodes('i') AS x(i)
       ) AS y
       WHERE Item IS NOT NULL
   )

CREATE PROCEDURE NEW_ORDER 
     @CUSTOMER_ID INT, @List VARCHAR(MAX), @List2 VARCHAR(MAX)
AS
BEGIN
    SET NOCOUNT ON;

    SELECT O.CUSTOMER_ID, O.ORDER_ID, OP.PRODUCT_ID FROM ORDERS AS O
	    INNER JOIN ORDERS_PRODUCT AS OP ON OP.ORDERS_ID = O.ID
        INNER JOIN SplitInts(@List, ',') AS list
        ON OP.PRODUCT_ID = list.Item
		GROUP BY O.ORDER_ID, O.CUSTOMER_ID
		HAVING O.CUSTOMER_ID = @CUSTOMER_ID
END
GO

EXEC NEW_ORDER @CUSTOMER_ID = 1, @List = '1, 2, 3', @List2 = '1, 2, 3'


/*Да се напише изглед, който да връща списък на активните клиенти (тези, които имат 
направени поръчки и не са блокирани).*/
CREATE VIEW ACTIVE_USERS AS
SELECT C.FIRST_NAME, C.LAST_NAME, C.AGE, C.EMAIL, C.PHONE_NUMBER, C.ADDRESS_INFO_ID__DEFAULT
FROM CUSTOMER AS C
INNER JOIN USER_INFO AS U ON U.ID = C.USER_INFO_ID
INNER JOIN ORDERS AS O ON O.CUSTOMER_ID = C.ID
GROUP BY C.ID, C.FIRST_NAME, C.LAST_NAME, C.AGE, C.EMAIL, C.PHONE_NUMBER, C.ADDRESS_INFO_ID__DEFAULT, U.IS_BLOCKED, U.IS_DELETED
HAVING U.IS_BLOCKED = 0 AND U.IS_DELETED = 0

SELECT * FROM ACTIVE_USERS


/*Да се напише UDF, който приема за параметър категория и дата и връща информация за 
поръчаните на или след тази дата продукти от тази категория и съответните поръчки.*/

CREATE FUNCTION PRODUCT_INFORMATION
(
@CATEGORY_ID INT,
@DATETIME DATETIME
)
RETURNS TABLE
AS 
   RETURN(
      SELECT O.DATETIME, C.NAME AS CATEGORY_NAME, P.NAME AS PRODUCT_NAME
	  FROM PRODUCT AS P
	  JOIN ORDERS_PRODUCT AS OP ON OP.ORDERS_ID = P.ID
	  JOIN ORDERS AS O ON O.ORDER_ID = OP.ORDERS_ID
	  JOIN CATEGORY AS C ON C.ID = P.CATEGORY_ID
	  GROUP BY O.DATETIME, C.NAME, P.NAME, P.CATEGORY_ID
	  HAVING O.DATETIME >= @DATETIME AND P.CATEGORY_ID = @CATEGORY_ID
   )

SELECT * FROM  PRODUCT_INFORMATION(1,'2023-01-07T15:49:15')


/* Най-често поръчваните продукти (бест селърите в магазина)*/
SELECT TOP 10 P.NAME, COUNT(OP.PRODUCT_ID) AS TIMES_PURCHASED
FROM PRODUCT AS P
JOIN ORDERS_PRODUCT AS OP ON OP.PRODUCT_ID = P.ID
GROUP BY P.NAME
ORDER BY COUNT(OP.PRODUCT_ID)


/* По зададен продукт, най-често поръчваните заедно с него продукти*/
SELECT TOP 5 P.ID, P.NAME, COUNT(OP.PRODUCT_ID) AS TIMES_PURCHASED
FROM PRODUCT AS P
INNER JOIN ORDERS_PRODUCT AS OP ON OP.PRODUCT_ID = P.ID
JOIN ORDERS AS O ON O.ID = OP.ORDERS_ID
GROUP BY P.ID, P.NAME
HAVING P.ID = 1 
ORDER BY COUNT(OP.PRODUCT_ID)


/* По зададен продукт, как се е променяла цената му в рамките на послените 30 дни*/
SELECT P.ID, P.NAME, PRI.DATE
FROM PRODUCT AS P
JOIN PRICE_INFO AS PRI ON PRI.PRODUCT_ID = P.ID
GROUP BY PRI.DATE, P.ID, P.NAME
HAVING P.ID = 1 AND PRI.DATE >= DATEADD(month, -1, GETDATE())
ORDER BY PRI.DATE


/*Каква е печалбата ни (разликата между продажните цени и доставните цени) за 
зададен период от време, като се взимат предвид само платените поръчки*/

SELECT SUM(PRI.SELLING_PRICE - PRI.DELIVERY_PRICE) AS PROFIT
FROM ORDERS AS O
JOIN ORDERS_PRODUCT AS OP ON OP.ORDERS_ID = O.ORDER_ID
JOIN PRODUCT AS P ON  P.ID = OP.PRODUCT_ID
JOIN PRICE_INFO AS PRI ON PRI.PRODUCT_ID = P.ID
GROUP BY O.DATETIME
HAVING O.DATETIME > '2020-01-01T00:00:00' AND O.DATETIME < '2024-01-01T00:00:00'
ORDER BY O.DATETIME


